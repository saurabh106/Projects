# So in prisma i understand that

There we are creating 2 ids one is the user.id and another is the clerkUserId
So as we now every user need a clerkUserId so we are updating that also and

# 1. id in the User model

This is the unique identifier for each user in your database.

It's like a name tag or ID card that says, "This is user #123."

It is generated by your database automatically (@default(uuid())).

It helps your system know exactly who each user is.

# 2. id in the Assessment model

This is the unique identifier for each assessment (test or quiz).

It tells your system, "This is assessment #abc."

This ID is also automatically generated (@default(cuid())).

It helps keep every assessment record separate and easy to find.

# 3. userId in the Assessment model

This is a special ID that links an assessment to a user.

It stores the id of the user who took the assessment.

##

user: This is the name of the field inside Assessment that represents the connected User object.

You can think of it like a property you can use in your code to get the full user details for an assessment.

# User: The type of this field — it points to the User model.

@relation(fields: [userId], references: [id]):

# fields: [userId]: This tells Prisma,

"In this model (Assessment), the userId field is the foreign key that stores the user’s ID."

# references: [id]: This tells Prisma,

"The userId field references the id field in the User model."

## react-hook-form || zod || @hookform/resolvers

# zod :

        Zod is a library that lets you define schemas (data shapes) and validate data against those schemas. It works well with TypeScript,
        providing both runtime validation and type inference.

# useForm :

        useForm is a hook provided by popular form libraries like React Hook Form. It's used to manage form state, validation, and submission in React applications.

# {...register("experience")}: Registers the field with React Hook Form using the register function.

# It links this field to the form's validation and state handling.

# Destructured values from useForm:

      register: Used to register input fields and link them to the form state/validation.
      handleSubmit: Used to handle form submission (onSubmit), triggering validation.
      formState.errors: Contains validation error messages for each field.
      setValue: Allows you to programmatically set the value of a form field.
      watch: Allows you to watch the value of one or more fields in real-time.

# So we need to called the update user after submit the form for that we already created that but we can't called it directly because they are not a server component

For that we are creating a hooks in that use-fetch.js in that we fetch data and run the updateuser function and that use in the onboarding-form

So we need to understand this that we create a hook that use to fetch and run data by using action/user.js we need to run the updatedUser so for that we create this hook and now we are using useFetch in the client component

# So basically i create a inngest function in that every sunday they updated that function and fetch the data by given prompt using Gemini ai fetch the latest industryinsight by using ai function name is generateIndustryInsights

generateQuiz – generates technical multiple-choice quiz questions using AI.

saveQuizResult – saves quiz results to the database and optionally generates improvement tips.

getAssessments – retrieves saved assessments from the database.

# Why we use use-fetch :

Why do we use this code?
Reusable Data Fetching Logic
Instead of writing similar code over and over in multiple components (like managing loading, error, and data state), this hook lets you encapsulate that logic once and reuse it everywhere.

Simplifies Async Calls
The fn function inside the hook wraps your asynchronous callback cb and handles setting the loading, error, and data states automatically when you call it. This reduces boilerplate.

Automatic Loading and Error Handling
When you call the fn function, the hook automatically:

Shows a loading state (loading becomes true)

Clears any previous errors

Tries to fetch the data

If an error occurs, it:

Saves the error state

Displays a toast notification to the user with a friendly error message (using sonner library)

Resets the loading state after the fetch attempt completes

Cleaner Components
Components using this hook don’t have to manage complex fetch logic or error handling directly. They just call fn and react to the state (loading, error, data), making UI code cleaner and easier to read.


# In action folder all are the server acions that perform on the server 
